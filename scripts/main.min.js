!function () {
    "use strict";

    var t = {
        cache: {},
        opts: { maxSpeed: 200 },
        localStorage: localStorage
    };

    // Enhanced buffer for better speed calculations
    var speedBuffer = [];
    var bufferSize = 10; // Increased buffer size for smoother readings
    var lastLocation = null;
    var calibrationOffset = 0; // For speed calibration
    var animationFrame;

    // Animation configurations
    const animations = {
        speedValue: {
            current: 0,
            target: 0,
            step: 0,
            frames: 15
        },
        bgColor: {
            currentHue: 120, // Green hue
            targetHue: 120
        }
    };

    function handleMeasurementClick(e) {
        localStorage.measure = e.target.id;
        document.getElementById("ms").classList.remove("active");
        document.getElementById("mh").classList.remove("active");
        document.getElementById("kh").classList.remove("active");
        e.target.classList.add("active");
        
        // Animate when switching units
        animateSpeedUpdate();
    }

    function init() {
        t.cache.speed = document.getElementById("speed");
        t.cache.speedContainer = document.getElementById("speedContainer") || t.cache.speed.parentElement;
        
        if (!t.localStorage.measure) {
            localStorage.measure = "kh"; // Default to kilometers per hour
            t.localStorage = localStorage;
        }
        
        // Set active state for the currently selected measurement unit
        document.getElementById(t.localStorage.measure).classList.add("active");
        
        initBtnClickListeners();
        document.getElementById("installer").style.display = "none";
        
        // Add calibration button only if not already present
        addCalibrationButton();

        // Start tracking speed after location permission is granted
        requestLocation();
        
        // Initialize animations
        startAnimationLoop();
    }

    function addCalibrationButton() {
        // Select the correct container. In your HTML, the calibrate button should be inside the .button-group element.
        const container = document.querySelector('.button-group');
        // Only add if a calibrate button doesn't already exist.
        if (container && !document.getElementById('calibrate')) {
            const calibrateBtn = document.createElement('button');
            calibrateBtn.id = 'calibrate';
            calibrateBtn.innerText = 'Calibrate';
            calibrateBtn.className = 'button';
            calibrateBtn.addEventListener('click', calibrateSpeed);
            container.appendChild(calibrateBtn);
        }
    }

    function calibrateSpeed() {
        // Reset buffer and set calibration offset
        speedBuffer = [];
        calibrationOffset = 0;
        
        // Visual feedback
        document.getElementById('calibrate').classList.add('active');
        setTimeout(() => {
            document.getElementById('calibrate').classList.remove('active');
        }, 1000);
        
        // Show calibration message
        const message = document.createElement('div');
        message.className = 'calibration-message';
        message.innerText = 'Calibrating...';
        document.body.appendChild(message);
        
        // Remove message after 3 seconds
        setTimeout(() => {
            message.classList.add('fadeOut');
            setTimeout(() => document.body.removeChild(message), 500);
        }, 2500);
    }

    function initBtnClickListeners() {
        document.getElementById("ms").addEventListener("click", handleMeasurementClick);
        document.getElementById("mh").addEventListener("click", handleMeasurementClick);
        document.getElementById("kh").addEventListener("click", handleMeasurementClick);
    }

    function requestLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(onLocationSuccess, onLocationError, {
                enableHighAccuracy: true
            });
        } else {
            displayError("Geolocation is not supported by this browser.");
        }
    }

    function onLocationSuccess(position) {
        // Start watching position to track speed with improved options
        navigator.geolocation.watchPosition(onSpeedUpdate, onLocationError, {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 3000 // 3-second timeout for faster updates
        });
    }

    function onSpeedUpdate(position) {
        document.getElementById("error").innerHTML = "";

        let calculatedSpeed;
        
        // Try to calculate speed manually if position.coords.speed is not available or unreliable
        if (position.coords.speed === null || position.coords.speed === 0) {
            if (lastLocation) {
                // Calculate speed based on distance and time
                const distance = calculateDistance(
                    lastLocation.coords.latitude,
                    lastLocation.coords.longitude,
                    position.coords.latitude,
                    position.coords.longitude
                );
                const timeDiff = (position.timestamp - lastLocation.timestamp) / 1000; // in seconds
                
                if (timeDiff > 0) {
                    calculatedSpeed = distance / timeDiff; // meters per second
                }
            }
        } else {
            calculatedSpeed = position.coords.speed;
        }
        
        // Update last location for next calculation
        lastLocation = position;

        // Check GPS accuracy
        const accuracyMessage = position.coords.accuracy > 20 
            ? `<span class="accuracy-warning">GPS Accuracy: ${Math.round(position.coords.accuracy)}m</span>` 
            : `<span class="accuracy-good">GPS Accuracy: ${Math.round(position.coords.accuracy)}m</span>`;
        document.getElementById("accuracy").innerHTML = accuracyMessage;

        // If speed is available (either from GPS or calculated)
        if (calculatedSpeed !== undefined && calculatedSpeed !== null) {
            // Apply moving average filter with outlier rejection
            speedBuffer.push(calculatedSpeed);
            if (speedBuffer.length > bufferSize) {
                speedBuffer.shift(); // Remove oldest reading
            }
            
            // Filter out obvious outliers (values too different from the average)
            if (speedBuffer.length >= 3) {
                const mean = speedBuffer.reduce((a, b) => a + b, 0) / speedBuffer.length;
                const filteredBuffer = speedBuffer.filter(speed => Math.abs(speed - mean) < mean * 0.5);
                
                // Only use filtered buffer if we still have enough data points
                if (filteredBuffer.length >= 3) {
                    var averageSpeed = filteredBuffer.reduce((a, b) => a + b, 0) / filteredBuffer.length;
                } else {
                    var averageSpeed = mean;
                }
            } else {
                var averageSpeed = speedBuffer.reduce((a, b) => a + b, 0) / speedBuffer.length;
            }
            
            // Apply calibration offset
            averageSpeed = Math.max(0, averageSpeed - calibrationOffset);

            // Convert speed based on selected measurement
            var unitText = "";
            if (t.localStorage.measure === "kh") {
                averageSpeed = averageSpeed * 3.6; // Convert to km/h
                unitText = "KM/h";
            } else if (t.localStorage.measure === "mh") {
                averageSpeed = averageSpeed * 2.23694; // Convert to miles/hour
                unitText = "Miles/hour";
            } else {
                unitText = "Meter/second";
            }

            averageSpeed = Math.round(averageSpeed * 10) / 10; // Round to 1 decimal place
            
            // Set animation target
            animations.speedValue.target = averageSpeed;
            animations.bgColor.targetHue = getSpeedHue(averageSpeed);
            
            document.getElementById("unit").innerHTML = unitText;

            // Update latitude and longitude with animation
            const latElement = document.getElementById("lat");
            const longElement = document.getElementById("long");
            
            latElement.innerHTML = `<strong>Latitude:</strong> ${position.coords.latitude.toFixed(5)}`;
            longElement.innerHTML = `<strong>Longitude:</strong> ${position.coords.longitude.toFixed(5)}`;
            
            latElement.classList.add('update');
            longElement.classList.add('update');
            
            setTimeout(() => {
                latElement.classList.remove('update');
                longElement.classList.remove('update');
            }, 500);
        } else {
            displayError("Speed data is not available. Try moving in a more open area.");
        }
    }
    
    // Color mapping based on speed
    function getSpeedHue(speed) {
        // Map speed to hue value (green->yellow->red)
        // Green: 120, Yellow: 60, Red: 0
        const threshold = t.localStorage.measure === "kh" ? 80 : 
                        t.localStorage.measure === "mh" ? 50 : 22;
        
        return Math.max(0, 120 - (speed / threshold) * 120);
    }
    
    // Calculate distance between two coordinates in meters (Haversine formula)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth radius in meters
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c; // Distance in meters
    }

    // Animation loop for smooth transitions
    function startAnimationLoop() {
        animationFrame = requestAnimationFrame(function animate() {
            // Animate speed value
            if (animations.speedValue.current !== animations.speedValue.target) {
                const diff = animations.speedValue.target - animations.speedValue.current;
                animations.speedValue.step = diff / animations.speedValue.frames;
                animations.speedValue.current += animations.speedValue.step;
                
                if (Math.abs(animations.speedValue.current - animations.speedValue.target) < 0.1) {
                    animations.speedValue.current = animations.speedValue.target;
                }
                
                // Update display
                updateSpeedDisplay(animations.speedValue.current.toFixed(1));
            }
            
            // Animate background color
            if (Math.abs(animations.bgColor.currentHue - animations.bgColor.targetHue) > 1) {
                animations.bgColor.currentHue += (animations.bgColor.targetHue - animations.bgColor.currentHue) * 0.1;
                
                // Change background color based on speed
                const speedContainer = t.cache.speedContainer;
                if (speedContainer) {
                    speedContainer.style.backgroundColor = `hsl(${animations.bgColor.currentHue}, 80%, 50%)`;
                    speedContainer.style.boxShadow = `0 0 20px hsl(${animations.bgColor.currentHue}, 80%, 50%)`;
                }
            }
            
            // Continue animation loop
            animationFrame = requestAnimationFrame(animate);
        });
    }

    // Function to animate speed updates
    function animateSpeedUpdate() {
        const displayValue = parseFloat(t.cache.speed.innerHTML);
        if (!isNaN(displayValue)) {
            // Convert current value to new unit before animation
            let newValue;
            if (t.localStorage.measure === "kh" && speedBuffer.length > 0) {
                const mps = speedBuffer.reduce((a, b) => a + b, 0) / speedBuffer.length;
                newValue = mps * 3.6;
            } else if (t.localStorage.measure === "mh" && speedBuffer.length > 0) {
                const mps = speedBuffer.reduce((a, b) => a + b, 0) / speedBuffer.length;
                newValue = mps * 2.23694;
            } else if (speedBuffer.length > 0) {
                newValue = speedBuffer.reduce((a, b) => a + b, 0) / speedBuffer.length;
            } else {
                return; // No data to convert
            }
            
            // Set new target for animation
            animations.speedValue.target = Math.round(newValue * 10) / 10;
        }
    }

    // Enhanced speed display with multiple animation effects
    function updateSpeedDisplay(speed) {
        t.cache.speed.innerHTML = speed;
        
        // Apply multiple animations
        t.cache.speed.classList.remove('pulse', 'bounce', 'flash');
        
        // Choose animation based on speed change
        const prevSpeed = parseFloat(t.cache.speed.dataset.prevSpeed || 0);
        const currentSpeed = parseFloat(speed);
        t.cache.speed.dataset.prevSpeed = currentSpeed;
        
        // Choose animation based on speed change
        if (Math.abs(currentSpeed - prevSpeed) > 5) {
            t.cache.speed.classList.add('flash'); // Big change - flash
        } else if (currentSpeed > prevSpeed) {
            t.cache.speed.classList.add('bounce'); // Speed increasing - bounce
        } else {
            t.cache.speed.classList.add('pulse'); // Default or decreasing - pulse
        }
        
        // Scale animation based on speed
        const scale = 1 + Math.min(0.3, currentSpeed / 200);
        t.cache.speed.style.transform = `scale(${scale})`;
        
        // Reset transform after animation completes
        setTimeout(() => {
            t.cache.speed.style.transform = '';
        }, 300);
    }

    function onLocationError(error) {
        var errorMessage;
        switch (error.code) {
            case error.PERMISSION_DENIED:
                errorMessage = "User denied the request for Geolocation.";
                break;
            case error.POSITION_UNAVAILABLE:
                errorMessage = "Location information is unavailable.";
                break;
            case error.TIMEOUT:
                errorMessage = "The request to get user location timed out.";
                break;
            case error.UNKNOWN_ERROR:
                errorMessage = "An unknown error occurred.";
                break;
        }
        displayError("ERROR(" + error.code + "): " + errorMessage);
    }

    function displayError(message) {
        document.getElementById("speed").innerHTML = "...";
        document.getElementById("error").innerHTML = message;
        document.getElementById("lat").innerHTML = "<strong>Latitude:</strong> ERROR!!!";
        document.getElementById("long").innerHTML = "<strong>Longitude:</strong> ERROR!!!";
        document.getElementById("info").style.display = "block";
        
        // Add shaking animation to error message
        const errorElement = document.getElementById("error");
        errorElement.classList.add('shake');
        setTimeout(() => {
            errorElement.classList.remove('shake');
        }, 820);
    }

    // Add required CSS animations
    function addAnimationStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .pulse {
                animation: pulse-animation 0.3s ease-in-out;
            }
            @keyframes pulse-animation {
                0% { transform: scale(1); }
                50% { transform: scale(1.2); }
                100% { transform: scale(1); }
            }
            
            .bounce {
                animation: bounce-animation 0.5s ease-in-out;
            }
            @keyframes bounce-animation {
                0%, 100% { transform: translateY(0); }
                40% { transform: translateY(-20px); }
                60% { transform: translateY(-15px); }
            }
            
            .flash {
                animation: flash-animation 0.5s ease-in-out;
            }
            @keyframes flash-animation {
                0%, 50%, 100% { opacity: 1; }
                25%, 75% { opacity: 0.3; }
            }
            
            .shake {
                animation: shake-animation 0.82s cubic-bezier(.36,.07,.19,.97) both;
            }
            @keyframes shake-animation {
                10%, 90% { transform: translate3d(-1px, 0, 0); }
                20%, 80% { transform: translate3d(2px, 0, 0); }
                30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
                40%, 60% { transform: translate3d(4px, 0, 0); }
            }
            
            .update {
                animation: update-animation 0.5s ease-in-out;
            }
            @keyframes update-animation {
                0% { opacity: 0.3; }
                100% { opacity: 1; }
            }
            
            .calibration-message {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0,0,0,0.8);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                z-index: 1000;
                animation: fadein 0.5s;
            }
            
            .fadeOut {
                animation: fadeout 0.5s forwards;
            }
            
            @keyframes fadein {
                from { opacity: 0; }
                to   { opacity: 1; }
            }
            
            @keyframes fadeout {
                from { opacity: 1; }
                to   { opacity: 0; }
            }
            
            .accuracy-warning {
                color: orange;
                animation: blink 1s infinite;
            }
            
            .accuracy-good {
                color: green;
            }
            
            @keyframes blink {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
        `;
        document.head.appendChild(style);
    }

    document.addEventListener("DOMContentLoaded", function() {
        init();
        addAnimationStyles();
        
        // Add accuracy div if it doesn't exist
        if (!document.getElementById("accuracy")) {
            const infoDiv = document.getElementById("info");
            const accuracyDiv = document.createElement("div");
            accuracyDiv.id = "accuracy";
            infoDiv.appendChild(accuracyDiv);
        }
    });

    // PWA Install Prompt Handling
    let deferredPrompt;

    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        const installer = document.getElementById('installer');
        if (installer) {
            installer.style.display = 'block';
            // Add animation to installer button
            installer.classList.add('pulse');
        }
    });

    function installPrompt() {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                } else {
                    console.log('User dismissed the install prompt');
                }
                deferredPrompt = null;
            });
        }
    }

    // Make sure installer exists before adding event listener
    document.addEventListener('DOMContentLoaded', function() {
        const installer = document.getElementById('installer');
        if (installer) {
            installer.addEventListener('click', installPrompt);
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
    });

    // Disable Right-Click
    document.addEventListener('contextmenu', function(event) {
        event.preventDefault();
    });

    // Disable Keyboard Shortcuts for Inspect (F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U, etc.)
    document.addEventListener('keydown', function(event) {
        if (event.key === 'F12') {
            event.preventDefault();
        }
        if (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key)) {
            event.preventDefault();
        }
        if (event.ctrlKey && event.key === 'U') {
            event.preventDefault();
        }
    });
}();
